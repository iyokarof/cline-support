# コーディング原則 (読みやすさ重視)

## アーキテクチャ設計原則

1. **クリーンアーキテクチャの適用**:
   * ドメイン層、アプリケーション層、インフラストラクチャ層、プレゼンテーション層に明確に分離してください。
   * 依存関係は外側から内側への一方向のみとし、依存性逆転の原則を適用してください。
   * ドメイン層は他のレイヤーに依存せず、純粋なビジネスロジックのみを含めてください。

2. **DDD（ドメイン駆動設計）の実践**:
   * エンティティと値オブジェクトを明確に区別し、ビジネスルールをドメインオブジェクトに内包してください。
   * リポジトリパターンを使用してデータアクセスを抽象化してください。
   * ユビキタス言語を活用し、ドメイン専門家と開発者が同じ言葉で議論できるようにしてください。

3. **関数型プログラミングの採用**:
   * エラーハンドリングとnull安全性を型レベルで保証してください。
   * イミュータブルな設計を原則とし、全てのプロパティをreadonlyにしてください。
   * 副作用を分離し、純粋関数を可能な限り使用してください。

## 実装原則

1. **設計への忠実性**:
   * 機能設計書の `coreLogicSteps` の順序と意図を尊重し、コードに反映してください。
   * 設計書の `inputs`, `outputs`, `errorHandling` の仕様を正確に実装してください。
   * ユビキタス言語情報辞書を参照し、そこに記載されている既存のルールに違反しないでください。

2. **命名規則**:
   * 変数名、関数名、クラス名等は、設計書内の概念名や `purpose` を参考に、その役割とデータ型が明確にわかるように、具体的かつ一貫性のある命名をしてください。
   * 言語特有の慣習があればそれに従ってください (例: Pythonではスネークケース、TypeScriptではキャメルケースなど)。
   * ドメイン用語は正確に使用し、略語は避けてください。

3. **構造とモジュール性**:
   * `coreLogicSteps` のステップごとに関数として分割してください。
   * `coreLogicSteps` の各ステップが複雑な場合、適切にヘルパー関数やクラスに分割してください。
   * 各関数/メソッドは、単一の責任を持つように設計してください。
   * ネストは浅く保ち (推奨2レベル以内)、早期リターンなどを活用してコードの流れを平易にしてください。

4. **明確性と簡潔性**:
   * コードは、その処理内容が直接的に理解できるように記述してください。トリッキーな記述や過度に技巧的な表現は避けてください。
   * 冗長なコードは避け、DRY (Don't Repeat Yourself) 原則を意識してください。
   * マジックナンバーやハードコードされた文字列リテラルは避け、意味のある名前の定数として定義してください。

5. **型安全性とイミュータビリティ**:
   * 全てのプロパティをreadonlyにし、イミュータブルな設計を採用してください。
   * エラーハンドリングとnull安全性を型レベルで保証してください。
   * 更新操作は新しいオブジェクトを返す関数型スタイルで実装してください。

6. **副作用の管理**:
   * 関数は可能な限り純粋に保ち、入力に対して同じ出力を返すようにしてください。
   * 宣言的かつイミュータブルであることを原則としてください。
   * 副作用を伴う処理 (ファイル操作、ネットワーク通信、グローバル状態の変更など) は、可能な限り関数の境界に寄せ、純粋なロジック部分と分離してください。
   * 副作用がある関数は、そのことが明確にわかるように命名やドキュメントで示してください。

7. **エラー処理**:
   * 設計書の `errorHandling` の方針に従い、エラーが発生した場合の処理フローを明確に記述してください。
   * Result型を使用して明示的なエラー処理を行い、例外の使用は最小限に留めてください。
   * エラーメッセージは定数化し、国際化を考慮してください。

8. **依存注入と疎結合**:
   * インターフェースを通じた依存注入を活用し、レイヤー間の結合を疎にしてください。
   * コンストラクター注入を基本とし、依存関係を明示的にしてください。
   * テスタビリティを向上させるため、具象クラスではなくインターフェースに依存してください。

9. **コメントとドキュメンテーション**:
   * 全ての公開関数/メソッド/クラスには、その目的、主要な引数、戻り値を説明する簡潔なドキュメントコメントを付与してください。
   * 複雑なロジックや、一見して意図が分かりにくい部分には、その「なぜ」を説明するコメントを簡潔に追加してください。ただし、コード自体で表現できることはコメントで繰り返さないでください。
   * 自然言語は日本語を使用してください。
   * ドメイン知識やビジネスルールに関する重要な決定事項は、コメントまたは設計書に記録してください。

## テスト実装原則

1. **テスト構造とカバレッジ**:
   * 全てのinfrastructure層クラスに対してユニットテストを実装してください。
   * C0カバレッジ90%以上を目標とし、正常系・異常系・エラーケースを網羅してください。
   * AAA（Arrange-Act-Assert）パターンに従い、テストの構造を明確にしてください。
   * テスト名は日本語で、何をテストしているかが明確にわかるように記述してください。

2. **テスト分離とモック化**:
   * 外部依存関係は適切にモック化し、テスト対象クラスの動作のみを検証してください。
   * ファイルシステムに依存するテストでは、一時ディレクトリを使用して実際のファイルシステムから分離してください。
   * MCPサーバーやExpressサーバーのテストでは、SDK、Transport、ミドルウェアをモック化してください。
   * beforeEach/afterEachを使用してテスト環境のリセットを確実に行ってください。

3. **関数型プログラミング型のテスト**:
   * Result型・Option型のテストでは型ガードパターンを使用してください:
     ```typescript
     expect(result.success).toBe(true);
     if (!result.success) return;  // TypeScript型ガード
     expect(result.value.someProperty).toBe(expected);
     ```
   * 型安全性を保ちながらテストアサーションを実行するため、early return パターンを活用してください。
   * モナド型特有のメソッドチェーンは避け、フラットな構造でテストを記述してください。

4. **Jest設定（ESModulesプロジェクト）**:
   * ESModulesとTypeScriptの組み合わせでは複雑な設定が必要です:
     ```javascript
     // jest.config.cjs
     module.exports = {
       preset: 'ts-jest',
       moduleNameMapper: {
         '^(\\.{1,2}/.*)\\.js$': '$1'
       },
       transform: {
         '^.+\\.ts$': ['ts-jest', {
           tsconfig: { module: 'ES2022', target: 'ES2022' }
         }]
       }
     };
     ```
   * import.meta.url使用時はJest設定でのTypeScriptコンパイラオプション調整が必要です。
   * package.json で "type": "module" を使用する場合、jest.config.cjs（CommonJS）形式で設定ファイルを作成してください。

5. **モック実装パターン**:
   * jest.mock()は自動モック化に使用し、複雑なオブジェクトはObject.assignでモック化してください:
     ```typescript
     // 複雑なオブジェクトのモック例
     jest.mock('express', () => {
       const mockExpress = jest.fn(() => mockApp);
       Object.assign(mockExpress, {
         json: jest.fn(() => 'json-middleware'),
         Router: jest.fn(() => mockRouter)
       });
       return mockExpress;
     });
     ```
   * TypeScript型安全性のため、MockedClass<T>型を使用してモックの型定義を行ってください。
   * プロセス終了テスト（process.exit）では、モック化して例外をthrowするパターンを使用してください。

6. **テストの保守性**:
   * テストは理解しやすく、変更に強いコードで記述してください。
   * テストデータは可読性を重視し、テスト内で定義するか、共通のfactoryパターンを使用してください。
   * 一時的なリソース（ファイル、ディレクトリ）は確実にクリーンアップしてください。
   * テストタイムアウトは適切に設定し（推奨：10秒以内）、長時間実行されるテストは避けてください。

7. **エラーケーステスト**:
   * 想定されるエラー条件を網羅的にテストしてください：
     - ファイルI/Oエラー（ファイル不存在、権限エラー）
     - JSON解析エラー（不正フォーマット）
     - ネットワークエラー（接続失敗、タイムアウト）
     - バリデーションエラー（不正入力）
   * エラーハンドリングロジックが適切に動作することを確認してください。
   * ログ出力やエラーメッセージの内容も検証に含めてください。
