{
  "features": [
    {
      "feature": {
        "name": "FeatureDefinitionManager",
        "purpose": "プロジェクトの機能定義を管理し、追加・更新・削除・取得を行う機能",
        "userStories": [
          "開発者として、新しい機能定義を追加したい",
          "開発者として、既存の機能定義を更新したい",
          "開発者として、不要な機能定義を削除したい",
          "開発者として、機能定義の詳細を取得したい"
        ]
      },
      "inputs": [
        {
          "name": "featureDefinition",
          "dataTypeDescription": "機能定義オブジェクト。名前、目的、ユーザーストーリー、入力、出力、コアロジックステップ、エラーハンドリング等を含む",
          "constraints": [
            "feature.nameは必須で空文字列不可",
            "feature.purposeは必須で空文字列不可",
            "全ての配列フィールドは必須"
          ],
          "purpose": "管理対象となる機能定義の完全な仕様"
        },
        {
          "name": "featureName",
          "dataTypeDescription": "文字列。機能の一意識別子",
          "constraints": [
            "空文字列不可",
            "最小長1文字以上"
          ],
          "purpose": "削除や検索時の機能特定"
        }
      ],
      "outputs": [
        {
          "condition": "機能定義が正常に追加された場合",
          "dataDescription": "操作結果オブジェクト。追加されたことを示すフラグと機能名",
          "structureHint": {
            "isUpdate": false,
            "featureName": "string"
          }
        },
        {
          "condition": "機能定義が正常に更新された場合",
          "dataDescription": "操作結果オブジェクト。更新されたことを示すフラグと機能名",
          "structureHint": {
            "isUpdate": true,
            "featureName": "string"
          }
        },
        {
          "condition": "機能定義が正常に削除された場合",
          "dataDescription": "削除結果オブジェクト",
          "structureHint": {
            "found": true,
            "featureName": "string"
          }
        },
        {
          "condition": "バリデーションエラーが発生した場合",
          "dataDescription": "エラー情報オブジェクト",
          "structureHint": {
            "isError": true,
            "message": "string"
          }
        }
      ],
      "coreLogicSteps": [
        {
          "stepNumber": 1,
          "description": "入力パラメータのバリデーション実行",
          "inputs": [
            "featureDefinition",
            "featureName"
          ],
          "output": "validationResult"
        },
        {
          "stepNumber": 2,
          "description": "既存機能定義の存在確認",
          "inputs": [
            "featureName",
            "designDocument"
          ],
          "output": "existingFeatureIndex"
        },
        {
          "stepNumber": 3,
          "description": "機能定義の追加または更新実行",
          "inputs": [
            "featureDefinition",
            "existingFeatureIndex",
            "designDocument"
          ],
          "output": "updatedDesignDocument"
        },
        {
          "stepNumber": 4,
          "description": "設計書ファイルへの永続化",
          "inputs": [
            "updatedDesignDocument"
          ],
          "output": "saveResult"
        }
      ],
      "errorHandling": [
        {
          "errorCondition": "入力パラメータのバリデーション失敗",
          "detectionPoint": "ステップ1",
          "handlingStrategyDescription": "バリデーションエラーメッセージを含むエラーレスポンスを返す",
          "resultingOutputCondition": "バリデーションエラーが発生した場合"
        },
        {
          "errorCondition": "ファイル保存の失敗",
          "detectionPoint": "ステップ4",
          "handlingStrategyDescription": "ファイルシステムエラーを適切にラップしてエラーレスポンスを返す",
          "resultingOutputCondition": "バリデーションエラーが発生した場合"
        }
      ],
      "nonFunctionalRequirements": [
        {
          "requirement": "データ整合性の保証",
          "considerationsForLogic": "ステップ2-4をアトミックに実行し、失敗時は元の状態を保持"
        },
        {
          "requirement": "型安全性の確保",
          "considerationsForLogic": "ステップ1でTypeScriptの型システムとランタイムバリデーションを併用"
        }
      ],
      "documentationNotes": [
        "機能定義は設計書ファイル（design.json）に永続化される",
        "既存機能名との重複チェックは配列の線形検索で実装",
        "バリデーションは型定義とランタイム検証の二重チェック"
      ]
    },
    {
      "feature": {
        "name": "InfrastructureLayerTesting",
        "purpose": "infrastructure層のクラスに対して高品質なユニットテストを実装し、90%以上のコードカバレッジと包括的なエラーハンドリングテストを提供する",
        "userStories": [
          "開発者として、infrastructure層の動作が確実であることを検証したい",
          "開発者として、リファクタリング時に既存機能が壊れていないことを確認したい",
          "開発者として、エラーケースが適切に処理されることを保証したい"
        ]
      },
      "inputs": [
        {
          "name": "targetClasses",
          "dataTypeDescription": "テスト対象のinfrastructure層クラス群",
          "constraints": [
            "FileSystemFeatureRepository",
            "FileSystemTermRepository",
            "ClineSupportServer",
            "RestServer"
          ],
          "purpose": "ユニットテスト実装対象の特定"
        },
        {
          "name": "testFramework",
          "dataTypeDescription": "テストフレームワークとその設定",
          "constraints": [
            "Jest",
            "ts-jest",
            "TypeScript",
            "ESModules対応"
          ],
          "purpose": "テスト実行環境の構築"
        },
        {
          "name": "mockingStrategy",
          "dataTypeDescription": "モック化戦略",
          "constraints": [
            "外部依存関係のモック化",
            "ファイルシステム分離",
            "ネットワーク層モック"
          ],
          "purpose": "テスト分離と信頼性確保"
        }
      ],
      "outputs": [
        {
          "condition": "正常実装時",
          "dataDescription": "動作するユニットテストスイート",
          "structureHint": {
            "testFiles": "4つのテストファイル",
            "coverage": "90%以上",
            "testCases": "正常系・異常系・エラーケースを網羅"
          }
        },
        {
          "condition": "設定問題発生時",
          "dataDescription": "ESModules互換性の課題と解決方法",
          "structureHint": {
            "issue": "import.meta.url TypeScriptエラー",
            "workaround": "Jest設定調整またはCommonJS変換"
          }
        }
      ],
      "coreLogicSteps": [
        {
          "stepNumber": 1,
          "description": "Jest環境設定：ESModules対応TypeScript設定",
          "inputs": [
            "package.json",
            "tsconfig.json",
            "jest.config.cjs"
          ],
          "output": "テスト実行環境"
        },
        {
          "stepNumber": 2,
          "description": "リポジトリクラステスト：ファイルシステム分離テスト",
          "inputs": [
            "FileSystemFeatureRepository",
            "FileSystemTermRepository"
          ],
          "output": "persistence層テストスイート"
        },
        {
          "stepNumber": 3,
          "description": "サーバークラステスト：外部依存モック化",
          "inputs": [
            "ClineSupportServer",
            "RestServer"
          ],
          "output": "サーバー層テストスイート"
        },
        {
          "stepNumber": 4,
          "description": "Result型・Option型対応：型ガード実装",
          "inputs": [
            "関数型プログラミング型定義"
          ],
          "output": "型安全なテストコード"
        },
        {
          "stepNumber": 5,
          "description": "カバレッジ設定：90%閾値設定と確認",
          "inputs": [
            "テストスイート",
            "Jest設定"
          ],
          "output": "品質保証レポート"
        }
      ],
      "errorHandling": [
        {
          "errorCondition": "ESModules import.meta.url TypeScriptエラー",
          "detectionPoint": "ステップ1",
          "handlingStrategyDescription": "Jest設定でmodule: ES2022指定、またはCommonJS変換",
          "resultingOutputCondition": "設定問題発生時"
        },
        {
          "errorCondition": "モック設定エラー",
          "detectionPoint": "ステップ2-3",
          "handlingStrategyDescription": "jest.mock()の正しい配置、MockedClass型定義、Object.assign使用",
          "resultingOutputCondition": "正常実装時"
        },
        {
          "errorCondition": "型ガードエラー",
          "detectionPoint": "ステップ4",
          "handlingStrategyDescription": "Result.success確認後のreturn文、型ナローイング実装",
          "resultingOutputCondition": "正常実装時"
        }
      ],
      "nonFunctionalRequirements": [
        {
          "requirement": "テスト実行時間：10秒以内",
          "considerationsForLogic": "一時ファイル操作の最適化、並列実行制御"
        },
        {
          "requirement": "テスト分離：他テストへの影響なし",
          "considerationsForLogic": "beforeEach/afterEachでの環境リセット、一意な一時ディレクトリ使用"
        },
        {
          "requirement": "保守性：理解しやすいテストコード",
          "considerationsForLogic": "AAA（Arrange-Act-Assert）パターン、明確なテスト名、適切なコメント"
        }
      ],
      "documentationNotes": [
        "ESModulesプロジェクトでのJest設定は複雑で、import.meta.url使用時に注意が必要",
        "infrastructure層テストでは外部依存関係の適切なモック化が重要",
        "Result型・Option型を使った関数型プログラミングパターンでは型ガードによる型安全性確保が必須",
        "ファイルシステムテストでは一時ディレクトリを使った分離が信頼性確保の鍵",
        "MCPサーバーやExpressサーバーのテストではシグナルハンドリングやミドルウェアのテストも重要"
      ]
    }
  ],
  "terms": [
    {
      "term": {
        "name": "機能定義",
        "definition": "ソフトウェアシステムが提供する特定の機能の仕様を記述した構造化された情報",
        "aliases": [
          "Feature",
          "FeatureDefinition",
          "機能仕様"
        ],
        "context": {
          "boundedContext": "設計管理コンテキスト",
          "scope": "プロジェクト全体の機能設計と実装の架け橋となる中核概念"
        }
      },
      "details": {
        "category": "エンティティ",
        "examples": [
          {
            "scenario": "新しい検索機能を開発する場合",
            "description": "検索キーワード入力から結果表示までの処理フローを、入力・出力・コアロジックステップとして構造化して記述"
          },
          {
            "scenario": "既存のユーザー管理機能を改修する場合",
            "description": "現在の機能定義を更新し、新しい要件やエラーハンドリングを追加"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "単なる要件定義書ではなく、実装に直接つながる構造化された仕様",
          "コード実装そのものではなく、実装の論理的な設計図",
          "テストケースや詳細な画面仕様は含まない"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "設計書",
            "relationshipType": "機能定義は設計書に格納される"
          },
          {
            "termName": "コアロジックステップ",
            "relationshipType": "機能定義はコアロジックステップを含む"
          }
        ],
        "associatedFunctions": [
          "FeatureDefinitionManager"
        ]
      },
      "implementation": {
        "codeMapping": "Feature interface in types.ts",
        "dataStructureHint": {
          "feature": {
            "name": "string",
            "purpose": "string",
            "userStories": "string[]"
          },
          "inputs": "Input[]",
          "outputs": "Output[]",
          "coreLogicSteps": "CoreLogicStep[]"
        },
        "constraints": [
          "feature.nameは一意である必要がある",
          "すべての配列フィールドは空でも良いが、nullは不可",
          "coreLogicStepsのstepNumberは連続した正の整数"
        ]
      }
    },
    {
      "term": {
        "name": "設計書",
        "definition": "プロジェクトの機能定義とユビキタス言語情報を統合管理する構造化文書",
        "aliases": [
          "DesignDocument",
          "設計文書"
        ],
        "context": {
          "boundedContext": "設計管理コンテキスト",
          "scope": "プロジェクト全体の設計情報の中央集約化と整合性管理"
        }
      },
      "details": {
        "category": "エンティティ",
        "examples": [
          {
            "scenario": "プロジェクト初期化時",
            "description": "空の機能定義配列と用語配列を持つ設計書を作成"
          },
          {
            "scenario": "機能追加時",
            "description": "既存の設計書に新しい機能定義を追加し、関連する用語も更新"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "単なるドキュメントではなく、システムの動作に直接影響する構造化データ",
          "コードそのものではないが、コード生成の基盤となる",
          "バージョン管理の対象となる永続化されたアーティファクト"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "機能定義",
            "relationshipType": "設計書は複数の機能定義を含む"
          },
          {
            "termName": "ユビキタス言語",
            "relationshipType": "設計書は複数のユビキタス言語情報を含む"
          }
        ],
        "associatedFunctions": [
          "FeatureDefinitionManager"
        ]
      },
      "implementation": {
        "codeMapping": "DesignDocument interface in types.ts",
        "dataStructureHint": {
          "features": "Feature[]",
          "terms": "Term[]"
        },
        "constraints": [
          "featuresとtermsは必須配列（空配列は許可）",
          "JSONファイルとして永続化される",
          "UTF-8エンコーディングで保存される"
        ]
      }
    },
    {
      "term": {
        "name": "クリーンアーキテクチャ",
        "definition": "ソフトウェアシステムを複数の同心円状のレイヤーに分離し、依存関係を外側から内側へ一方向にする設計原則",
        "aliases": [
          "Clean Architecture",
          "オニオンアーキテクチャ",
          "ヘキサゴナルアーキテクチャ"
        ],
        "context": {
          "boundedContext": "アーキテクチャ設計コンテキスト",
          "scope": "システム全体のアーキテクチャ設計と実装方針"
        }
      },
      "details": {
        "category": "アーキテクチャパターン",
        "examples": [
          {
            "scenario": "MCPサーバーのリファクタリング",
            "description": "ドメイン層（エンティティ、値オブジェクト）、アプリケーション層（ユースケース）、インフラストラクチャ層（リポジトリ実装）、プレゼンテーション層（ハンドラー）に分離"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "単なるレイヤー分けではなく、依存性逆転の原則に基づく設計",
          "外部ライブラリや技術詳細はインフラストラクチャ層に隔離される"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "DDD",
            "relationshipType": "組み合わせて使用される設計手法"
          },
          {
            "termName": "機能定義",
            "relationshipType": "クリーンアーキテクチャで管理されるドメインオブジェクト"
          }
        ],
        "associatedFunctions": [
          "FeatureDefinitionManager"
        ]
      },
      "implementation": {
        "codeMapping": "src/ディレクトリ構造全体",
        "dataStructureHint": {
          "domain": "エンティティ、値オブジェクト、リポジトリI/F",
          "application": "ユースケース、アプリケーションサービス",
          "infrastructure": "リポジトリ実装、外部API接続",
          "presentation": "MCPハンドラー、DTO"
        },
        "constraints": [
          "依存関係は外側から内側への一方向のみ",
          "ドメイン層は他の層に依存しない",
          "インフラストラクチャ層はインターフェースを通じてのみアクセス"
        ]
      }
    },
    {
      "term": {
        "name": "DDD",
        "definition": "ドメイン駆動設計（Domain-Driven Design）。複雑なソフトウェアの核心にあるドメインとドメインロジックに焦点を当てた設計手法",
        "aliases": [
          "ドメイン駆動設計",
          "Domain-Driven Design"
        ],
        "context": {
          "boundedContext": "アーキテクチャ設計コンテキスト",
          "scope": "ビジネスドメインの複雑性を管理するための設計手法と実装パターン"
        }
      },
      "details": {
        "category": "設計手法",
        "examples": [
          {
            "scenario": "MCPサーバーのリファクタリング",
            "description": "機能定義とユビキタス言語情報をエンティティとして定義し、FeatureName・TermNameを値オブジェクトとして実装"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "単なるデータベース設計ではなく、ビジネスロジックとドメイン知識の表現",
          "技術的な実装詳細ではなく、ビジネス価値に焦点を当てる"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "クリーンアーキテクチャ",
            "relationshipType": "組み合わせて使用される設計手法"
          },
          {
            "termName": "機能定義",
            "relationshipType": "DDDのエンティティとして設計される"
          }
        ],
        "associatedFunctions": [
          "FeatureDefinitionManager"
        ]
      },
      "implementation": {
        "codeMapping": "src/domain/層全体",
        "dataStructureHint": {
          "entities": "Feature, Term",
          "valueObjects": "FeatureName, TermName",
          "repositories": "IFeatureRepository, ITermRepository"
        },
        "constraints": [
          "エンティティは一意のIDを持つ",
          "値オブジェクトはイミュータブル",
          "ドメインロジックはドメイン層に集約"
        ]
      }
    },
    {
      "term": {
        "name": "JestESModulesConfiguration",
        "definition": "ESModulesプロジェクトでJestを動作させるための設定パターン。TypeScriptとESModulesの組み合わせで必要となる複雑な設定を包含する",
        "aliases": [
          "Jest ES設定",
          "ESM Jest設定",
          "TypeScript Jest ESM"
        ],
        "context": {
          "boundedContext": "テスト環境構築",
          "scope": "ESModulesを使用するTypeScriptプロジェクトでのJest設定"
        }
      },
      "details": {
        "category": "技術設定パターン",
        "examples": [
          {
            "scenario": "import.meta.url使用プロジェクト",
            "description": "preset: 'ts-jest/presets/default-esm', extensionsToTreatAsEsm: ['.ts'], moduleNameMapper設定が必要"
          },
          {
            "scenario": "TypeScriptコンパイラエラー回避",
            "description": "transform設定でmodule: 'ES2022', target: 'ES2022'を明示的指定"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "CommonJSプロジェクトでは不要な設定",
          "Node.jsバージョンによって動作が異なる可能性",
          "ライブラリの互換性問題が発生することがある"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "TypeScriptTestConfiguration",
            "relationshipType": "包含関係"
          }
        ],
        "associatedFunctions": [
          "InfrastructureLayerTesting"
        ]
      },
      "implementation": {
        "codeMapping": "jest.config.cjs",
        "dataStructureHint": {
          "preset": "ts-jest/presets/default-esm",
          "extensionsToTreatAsEsm": "['.ts']",
          "transform": "ts-jest with ES2022 config",
          "moduleNameMapper": "JS extension mapping"
        },
        "constraints": [
          "Node.js ES modules support required",
          "ts-jest version compatibility"
        ]
      }
    },
    {
      "term": {
        "name": "MockingStrategy",
        "definition": "ユニットテストにおいて外部依存関係を分離し、テスト対象クラスの動作のみを検証するための技術戦略。infrastructure層テストで特に重要",
        "aliases": [
          "モック化戦略",
          "テスト分離戦略",
          "Dependencies Mocking"
        ],
        "context": {
          "boundedContext": "ユニットテスト",
          "scope": "外部依存関係を持つクラスのテスト分離"
        }
      },
      "details": {
        "category": "テスト設計パターン",
        "examples": [
          {
            "scenario": "ファイルシステムリポジトリテスト",
            "description": "一時ディレクトリを使用してファイルI/O操作を実際のファイルシステムから分離"
          },
          {
            "scenario": "MCPサーバーテスト",
            "description": "SDK Server, Transport, リポジトリクラスをjest.mockでモック化"
          },
          {
            "scenario": "RESTサーバーテスト",
            "description": "Express app, router, middlewareをObject.assignでモック化"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "統合テストとは異なり、実際の外部サービスは使用しない",
          "モック設定の複雑さとテストの信頼性のバランスが重要",
          "TypeScript型定義との整合性維持が必要"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "JestESModulesConfiguration",
            "relationshipType": "技術実装での依存関係"
          }
        ],
        "associatedFunctions": [
          "InfrastructureLayerTesting"
        ]
      },
      "implementation": {
        "codeMapping": "jest.mock(), MockedClass<T>, Object.assign patterns",
        "dataStructureHint": {
          "jestMock": "automatic mocking",
          "manualMock": "Object.assign for complex objects",
          "typeDefinition": "MockedClass<T> for type safety"
        },
        "constraints": [
          "Jest framework dependency",
          "TypeScript type compatibility",
          "Mock lifecycle management"
        ]
      }
    },
    {
      "term": {
        "name": "FunctionalTypeTestPattern",
        "definition": "Result型・Option型などの関数型プログラミング型をテストする際の型ガード適用パターン。TypeScriptの型安全性を保ちながらテストアサーションを実行する",
        "aliases": [
          "関数型テストパターン",
          "Result型テストパターン",
          "型ガードテスト"
        ],
        "context": {
          "boundedContext": "関数型プログラミング",
          "scope": "Result<T, E>とOption<T>型を使用するメソッドのテスト"
        }
      },
      "details": {
        "category": "テストコーディングパターン",
        "examples": [
          {
            "scenario": "Result型の成功パターンテスト",
            "description": "expect(result.success).toBe(true); if (!result.success) return; でTypeScript型ガード適用"
          },
          {
            "scenario": "Option型のSomeパターンテスト",
            "description": "expect(option.isSome).toBe(true); if (!option.isSome) return; で値アクセス前の型確認"
          },
          {
            "scenario": "エラーケーステスト",
            "description": "expect(result.success).toBe(false); でFailure型のアサーション実行"
          }
        ],
        "ambiguitiesAndBoundaries": [
          "型ガードなしでは TypeScript コンパイルエラーが発生",
          "early return パターンでテスト実行の継続性確保が重要",
          "モナド型特有のメソッドチェーンは避けてフラットな構造で記述"
        ]
      },
      "relationships": {
        "relatedTerms": [
          {
            "termName": "MockingStrategy",
            "relationshipType": "テスト実装での併用関係"
          }
        ],
        "associatedFunctions": [
          "InfrastructureLayerTesting"
        ]
      },
      "implementation": {
        "codeMapping": "if (!result.success) return; pattern in test files",
        "dataStructureHint": {
          "typeGuard": "runtime type checking with early return",
          "assertion": "Jest expect statements before type guard",
          "access": "safe property access after type narrowing"
        },
        "constraints": [
          "TypeScript strict mode required",
          "Jest testing framework",
          "Result/Option type definitions"
        ]
      }
    }
  ]
}